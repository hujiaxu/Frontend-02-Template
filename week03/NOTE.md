第三周学习笔记

### 一，表达式

**1.语法树**：在计算机科学中，抽象语法树(AST)，或简称为语法树，是源代码**<u>语法结构</u>**的一种抽象表示。

它以树状的形式表现编程语言的语法结构，树上的**每个节点**都表示源代码中的一种结构。(摘自维基百科)

​	语法树其实就是将一类标签转化为通用标识符，从而结构出的一个类似与属性结构的语法树

​	在语法树结构中，对二元表达式最为优雅和高效的方式是运算符优先级解析。

**2.运算符优先级**

在网上查找：以下的顺序就代表运算符的优先级

|  1   | .    []   ()                               |
| :--: | ------------------------------------------ |
|  2   | ++   --  - ~  !  delete  new  typeof  void |
|  3   | *   /   %                                  |
|  4   | +         -                                |
|  5   | <<   >>   >>>                              |
|  6   | <     <=    >    >=    instanceof          |
|  7   | ==   !=  ===   !==                         |
|  8   | &                                          |
|  9   | ^                                          |
|  10  | \|                                         |
|  11  | &&                                         |
|  12  | \|\|                                       |
|  13  | ? :                                        |
|  14  | =   赋值运算符                             |
|  15  | ，                                         |

课上老师所讲：

第一级运算符

- Member

  - a.b

  - a[b]

  - foo\`string\`

  - super.b

  - super['b']

  - new.target（此公式不能改变一个字母）

  - new Foo()

    

第二级运算符

- New
  - new Foo

第三级运算符

- Call

  - foo()

  - super()

  - foo()['b']

  - foo().b

  - foo()\`abc\`

    

第四级运算符

- update
  - a++
  - a--
  - --a
  - ++a

第五级运算符

- Unary

  - delete a.b

  - void foo()

  - typeof a

  - +a

  - -a

  - ~a

  - !a

  - await a

    

第六级运算符

- Exponental
  - **

第七级运算符

- Multiplicative
  - *，/，%

第八级运算符

- Additive
  - +，-

第九级运算符

- Shift
  - <<   >>    >>>

第十级运算符

- Relationship
  - <，>，<=，>=，instanceof，in

第十一级运算符

- Equality
  - ==
  - !=
  - ===
  - !==

第十二级运算符

- Bitwise
  - &，^，|

第十三级运算符

- Logical
  - &&
  - ||

第十四级运算符

- Conditional
  - ? :

**3.类型转换***

|           |      Number       |       String       |                Boolean                | Undefined | Null |   Object   | Symbol |
| :-------: | :---------------: | :----------------: | :-----------------------------------: | :-------: | :--: | :--------: | :----: |
|  Number   |         -         |       太复杂       |       0 =false，其它非0转为true       |     ❌     |  ❌   | Boxing装箱 |   ❌    |
|  String   |      太复杂       |         -          | 空字符串转为false，非空字符串转为true |     ❌     |  ❌   |   Boxing   |   ❌    |
|  Boolean  | true=1，false=0， |  ‘true’，‘false’   |                   -                   |     ❌     |  ❌   |   Boxing   |   ❌    |
| Undefined |        NaN        |    ‘Undefined’     |                 false                 |     -     |  ❌   |     ❌      |   ❌    |
|   Null    |         0         |       ‘null’       |                 false                 |     ❌     |  -   |     ❌      |   ❌    |
|  Object   |      valueOf      | valueOf，toString, |         true,所有对象都是true         |     ❌     |  ❌   |     -      |   ❌    |
|  Symbol   |         ❌         |         ❌          |                   ❌                   |     ❌     |  ❌   |   Boxing   |   -    |

**4.装箱和拆箱**

**4.1装箱**：是指将基本数据类型转换为对应的引用类型的操作。而装箱又分为 隐式装箱和显示装箱。

```
//隐士装箱：当读取一个基本类型的值(Number,Boolean,String)时,后台会自动创建一个该基本类型所对应的基本包装类型对象
var s1 = 'str'
var s2 = si.substring(1)
/*
以上代码执行步骤
1.创建String类型的一个实例   //  var s1 = new String('str')
2.在实例中调用制定的方法	   //  var s2 = s1.substring(1)
3.销毁这个实例              //  s1 = null
*/
```

```
//显示装箱：简单地说就是通过new操作符引出一个实例对象
//与隐式装箱不同的是，可以对new出来的对象进行属性和方法的添加。因为通过new操作符引出的对象实例在执行流离开当前作用域之前一直保留在内存中。
var s1 = new String('str')
s1.name = 'hujiaxu'
```

**4.2拆箱：**是指把相应的引用类型转换为基本的数据类型(Number，String，Boolean)。一般通过引用类型的valueOf()和toString()方法来实习。

```
//拆箱过程在内部调用了抽象操作：ToPrimitive，该操作接受两个参数，第一个参数是要转变的对象，第二个参数PreferredType是对象被期待转成的类型(该参数不是必须的，默认是Number类型)。
//具体的转换过程：默认情况下，ToPrimitive先检查对象是否有valueOf方法，如果有则返回基本类型值。否则，调用toString方法。如果valueOf()和toString()两者都没有，则产生TypeError错误。
//PreferredTypr影响valueOf和toString的调用顺序。默认情况下，先调用valueOf()方法如果PreferrenType的值为string。则先调用toString,在调用valueOf方法。
```

```
var o = {
		toString(): {return '2'}
		valueOf(): {return 1}
		[Symbol.toPrimitive](): {return 3}
	}
var x = {}
console.log(x[o]) // 1
console.log('x' + o) // x2
```

### 2.语句

**5.completion Record：**completion record用于描述异常，跳出等语句执行过程，它表示**一个语句执行完成之后**的结果。有三个字段

| [[type]]：表示完成的类型 | 有break，continue，return，throw，以及normal这几种类型 |
| ------------------------ | ------------------------------------------------------ |
| [[value]]                | 表示语句的返回值，如果没有返回值，则是empty            |
| [[target]]               | 表示语句的目标，通常是一个JavaScript标签               |

JavaScript正式依靠语句的Completion Record类型，方才可以在语句的复杂嵌套结构中，**实现各种控制**（是否表达的是语句的开始或者结束？）。

**5.1语句的分类**：

- 普通语句
  - 声明类语句
    - var声明
    - const声明
    - let声明
    - 函数声明
    - 类声明
  - 表达式声明
  - 空语句
  - with语句
  - debugger语句
- 语句块（就是两个大括号里面的语句）
- 控制型语句
  - if
  - switch
  - for语句
    - for
    - for…of
    - for-await-of
    - for…in
  - while
    - while
    - do…while
  - continue
  - break
  - return
  - throw
  - try
- 带标签的语句

**5.2普通语句中的Completion Record：**在JavaScript中，**我们把不带控制能力的语句称为普通语句**。普通语句已经在上面列出。

- 普通语句在执行时，从前到后顺次执行，没有任何分支或者重复执行逻辑
- 普通语句执行后，会得到[[type]]为normal的Completion Record，JavaScript引擎遇到这样的Completion Record会继续执行下一条语句。
- 这些语句中，只有**表达式语句**会产生[[value]](从引擎角度考虑，这个value没有什么用处？)

**5.3语句块中的Completion Record：**语句块是一种语句的复合结构，可以嵌套。在语句块里面需要注意的是：**语句块内部的语句的Completion Record的[[type]]类型**，如果不是normal的话，会打断语句块后面的语句执行(这样就达到了控制)。

- 比如语句块里面有一条[[type]]为return的语句，那么会切断下面的语句执行
- 如果在语句块中插入了一条return语句，产生了一个非normal记录，那么整个block就会成为非normal。**这种结构就保证了非normal的完成类型可以穿透复杂的语句嵌套结构，产生控制效果**。

**5.4控制型语句的Completion Record**：控制型语句分成两类，这两类语句的结合，会产生控制代码执行顺序和执行逻辑的效果，这也是我们编程的主要工作。

- 一类是对其内部造成影响：if，switch，while，for，try
- 另一类是对外部造成影响：break，continue，return，throw

**5.4.1这个内容不懂，尤其是表的消费和穿透**：

下表的**消费**是指当前语句会把对下一条/块语句的执行权转交给消费此语句的语句，比如for消费break，是吧break后面语句的执行权转交给for。

**Completion Record的核心是为了描述“代码控制权转移”**。**每一条语句执行完之后会产生一个记录，JS称作Completion Record，而在下一句代码执行时会参照上一条语句的记录**

![1594895494440](C:\Users\胡佳旭\AppData\Roaming\Typora\typora-user-images\1594895494440.png)



一般来说for/while-break/continue和try-throw这样比较符合逻辑的组合，是大家比较熟悉的，但是，实际上，我们控制语句跟break，continue，return，throw四种类型与控制语句两两组合产生的效果。

**表中的break和continue是不是位置错了？？？**

![1594895833073](C:\Users\胡佳旭\AppData\Roaming\Typora\typora-user-images\1594895833073.png)

|           |  break   | continue |  return  | throw |
| :-------: | :------: | :------: | :------: | :---: |
|    if     |   穿透   |   穿透   |   穿透   | 穿透  |
|  switch   |   消费   |   穿透   |   穿透   | 穿透  |
| for/while |   消费   |   消费   |   穿透   | 穿透  |
| function  |   报错   |   报错   |   消费   | 穿透  |
|    try    | 特殊处理 | 特殊处理 | 特殊处理 | 消费  |
|   catch   | 特殊处理 | 特殊处理 | 特殊处理 | 穿透  |
|  finally  | 特殊处理 | 特殊处理 | 特殊处理 | 穿透  |

**5.5带标签的语句的Completion Record**：实际上，任何JavaScript语句是可以加标签的，在语句前加上冒号，类似于label语句。大部分时候，这种东西类似于注释，没有任何用处。唯一的用处：与完成记录类型中的target相配合，用于跳出多层循环。

- break/continue语句如果跟了关键字，会产生带target的完成记录。一旦完成记录带了target，那么只有拥有对应的label的循环语句会**消费**它。

**6.语句**

- 简单语句
  - 表达式语句(语句的核心，计算机执行的基础驱动)
  - 空语句(只是一个分号)
  - debugger语句(winter老师认为它具有调试作用)
  - throw语句
  - continue语句
  - break语句
  - return语句

- 复合语句
  - block语句(是指{ } 里面的语句)
  - if语句
  - switch语句(不建议使用，容易出错，可以用if… else…语句代替)
  - 循环语句(Iteration Statement)
    - while(…)
    - do(…) while {…}
    - for( ;  ;  ) {…}
    - for(… in …) {…}
    - for(… of …) {…}
  - with语句
  - label语句(经常与break和continue联合使用，达到尽快退出循环的效果)
  - try语句(由三部分组成：try{…}catch(捕捉try扔出的错误,通常使用一个变量接受){…}finally{…}，)

- 声明
  - 函数声明：与类声明，const声明，let声明不同的是，函数声明的变量可以作用域当前的函数体，而且可以在使用后声明，相当于在当前模块的顶部执行声明语句。而另外三者声明的变量只作用于当前的block语句，不能在使用后声明，否则会报错。**所有的声明都有变量提升(预处理，)，只不过他们所作用的作用域不同，从而导致不同的结果。**
    - function
    - function *
    - async function
    - async function *
    - var
  - 类声明
  - const
  - let

### 3.结构

 https://juejin.im/post/5e22b391f265da3e204d8c14 这个文章里把微任务和宏任务讲的比较详细

**7.宏任务与微任务：**

- **本人理解**：个人把宏任务理解为一个容器，这个容器可以包含同步任务，异步任务(宏任务，微任务)，比如script标签包含的整体代码是一个最大的宏任务，而这个宏任务里可以包含其他小的宏任务，微任务以及同步任务，在这个宏任务基础上，按照同步任务，微任务，宏任务的顺序执行。微任务执行要早于宏任务，**这个早于是在下一个宏任务为参考对象的基础上的**

- **宏任务**：通俗的讲，可以把由宿主环境发起的任务称作为宏任务，可以将每次执行栈执行的代码当作是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)，每一个宏任务会从头到尾执行完毕，不会执行其他。（一个宏任务里面有可能包含一个或多个微任务，此时，在这一个宏任务里的微任务执行完之前，不会进行下一个宏任务）
- **微任务**：ES6之后，JavaScript引入了Promise标准，同时浏览器实现上多了一个micro task微任务概念，在ECMAScript中，microtask也被称为jobs。(当前，Promise也是JavaScript可以发布的唯一的微任务)
- **注意点**
  - 浏览器会先执行一个宏任务，紧接着执行当前执行栈产生的微任务，再进行渲染，然后再执行下一个宏任务。(可以把script标签当作第一个宏任务，script标签代码块里最外层的微任务可以把它们当作当前script标签的微任务)
  - 微任务和宏任务**不在一个任务队列**
    - 例如，setTimeout是一个宏任务，它的事件回调在宏任务队列，Promise.then()是一个微任务，它的事件回调在微任务队列，二者不是一个任务队列
    - 以chrome浏览器为例，有关渲染的都是在渲染进程里进行，渲染进程中的任务(DOM树构建，js解析…等等)需要主线程执行的任务都会在主线程中执行，而**浏览器维护了一套事件循环机制**，主线程上的任务都会被放到消息队列中，主线程会循环消息队列，并从头部取出任务进行执行，如果执行过程中产生其他任务需要主线程执行的，渲染过程中的其它线程会把该任务塞入到消息队列的尾部，**消息队列中的任务都是宏任务**(这段话的大概意思就是JS主线程的执行机制一次只能执行一个宏任务，而在执行的过程中，如果有其它任务如微任务添加进来，则会添加在该宏任务队列的尾部，进行执行。我的理解是消息队列中一次只能存放一个宏任务)
    - **微任务是如何产生的？**当执行到script脚本的时候，js引擎会为全局创建一个执行上下文，在该执行上下文中维护了一个微任务队列，**当遇到微任务，就会把微任务回调放在微任务队列里**，当所有的js代码执行完毕，在退出全局上下文之前引擎会去检查该队列，有回调就执行，没有就退出执行上下文，这也就是微任务要早于宏任务(**这里我理解为当前宏任务里面的微任务要早于下一个宏任务执行**)，也是大家常说的，每个宏任务都有一个微任务队列

![图解宏任务与微任务](https://user-gold-cdn.xitu.io/2020/1/18/16fb7adf5afc036d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



**8.事件循环**:

- JavaScript分为同步任务和异步任务
- 同步任务都在主线程上执行，会形成一个执行栈
- 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放一个事件回调
- 一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，将可运行的异步任务(任务队列中的事件回调，只要任务队列中有事件回调，就说明可以执行)添加到执行栈中(个人见到的由宿主发布的任务都是回调函数，同时，个人也理解为任务的调用在执行栈中执行，从而会调用任务)
- ![](https://user-gold-cdn.xitu.io/2020/1/18/16fb7acab03b35fa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 首先，执行栈开始顺序执行
- 然后判断是否为异步，异步则加入到异步线程中，最终**事件回调**给事件触发线程的任务队列中等待执行，**同步任务继续执行**
- 执行栈空的时候，询问任务队列是否有事件回调
- 任务队列中有事件回调则把回调加入执行栈末尾继续从第一步开始执行
- 直到任务队列中没有事件回调，则停止发起询问

**9.闭包**：函数和对其周围状态(lexical environment，词法环境)的引用捆绑在一起构成的闭包(closure)。也就是说，闭包可以让你从内部函数访问外部函数作用域。**在JavaScript中，每当函数被创建，就会在函数生成时生成闭包。**

- 词法(lexical)一词指的是，词法作用域根据源代码中声明变量的位置来确定该变量在何处使用。
- 嵌套函数可访问声明与它们外部作用域的变量。
- 闭包是由函数以及声明该函数的词法环境组合而成的。该闭包包含了这个闭包创建时作用域内任何**局部变量**。
- 在一个闭包内对变量的修改，不会影响到另外一个闭包的变量
- **注意：**
  - 闭包的产生可以延长作用域，而这种作用域机制引发了一个副作用，即闭包只能取得包含函数中任何变量的最后一个值。**解决这个问题的方案是使用更多的函数，特别是函数工厂**。
  - 如果不是某些特定任务需要使用闭包，在其他函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。
  - 在JavaScript中，所有函数都能访问它们上一层的作用域。同时，嵌套函数可以访问上一层的函数。
  - 正常情况下，外部访问不到函数的局部变量，可以通过在函数内部定义一个函数将局部变量返回出去，是外部能够访问。
  - 使用var定义的变量，所有的闭包都会共享同一个作用域
- **作用：**
  - 闭包可以让外部读取函数内部的变量
  - 闭包可以让函数的局部变量一直保存在内存中

**10.词法作用域(静态作用域)：**词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里决定的，因此当词法分析器处理代码时会保持代码作用域不变。JavaScript采用的是词法作用域，所以函数的作用域基于函数创建的位置。

- 词法作用域的规则：
  - 函数允许访问函数外部的数据
  - 整个代码结构中只有函数可以限定作用域
  - 作用规则首先使用提升规则分析
  - 如果当前作用域中有了名字了，就不考虑外面的名字

**11.执行上下文**：

- JavaScript引擎是一段一段地分析执行程序，**而不是**一行一行地分析执行程序。
- 当执行一段代码的时候，会进行一个“准备工作”
- JavaScript可执行的代码：
  - 全局代码
  - 函数代码
  - eval代码
- 当执行到函数的时候，就会进行”准备工作“，这里的准备工作就是“执行上下文”
- 当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文，当函数执行完毕的时候，就会将函数的执行上下文栈中弹出。
- **执行上下文的属性：**
  - 变量对象(variable object，VO)
    - 变量对象是与执行上下文的数据作用域，存储了在上下文中定义的变量和函数声明
    - 变量对象是在进入函数上下文的时候被创建的，它通过函数arguments属性初始化。arguments属性值是Arguments对象
  - 作用域链
  - this
- **执行上下文的代码过程**：
  - 进入执行上下文
    - **这时候的变量对象有可能会包括**
      - **1**.函数的所有形参(如果是函数上下文)
        - 由名称和对应值组成的一个变量对象的属性被创建
        - 没有实参，属性值设为undefined
      - **2.函数声明**
        - 由名称和对应值(函数对象-function-object)组成一个变量对象的属性被创建
        - 如果变量对象已经存在相同名称的属性，则**完全替换**这个属性
      - **3.变量声明**
        - 由名称和对应值(undefined)组成一个变量对象的属性被创建
        - 如果变量名称跟已经声明的形式参数或函数相同，则变量声明**不会干扰**(为什么会与上面的不同)已经存在的这类属性
  - 代码执行
    - 在这个阶段，会顺序执行代码，根据代码，修改变量对象的值
- **全局上下文：**全局上下文的变量对象就是全局对象
  - **全局对象**：
    - 全局对象是预定义的对象，作为JavaScript的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象，函数和属性。
    - 在顶层的JavaScript代码中，可以用关键字this引用全局对象。









































































